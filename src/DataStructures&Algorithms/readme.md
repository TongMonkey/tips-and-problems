## 数据结构与算法
1. 面试范围：都是基本的动态规划，回溯，数组遍历，链表，二叉树、排序、折半查找、最长连续子序列要求O(n)，快速排序考的最多
2. 一定会考察算法的复杂度是怎么推导出来的
3. 自测：做完leetcode前100

### 复杂度分析
1. 大O时间复杂度表示法：
   1. 只表示数据规模n很大时候的执行效率
   2. 忽略低阶、常量、系数，只保留最高“量级”
   3. 表示执行时间随数据规模的增长趋势，而不是具体的执行时间
2. 对数级复杂度都支持换底，最终归为O(logN) 例如 
   ```
   log3(n) = log3(2) * log2(n); log3(2)是常数级别
   最终还是归为log2(n) 简化为logN了
   ```
3. 各个数据结构常见时间复杂度
   1. O(1) 哈希表
   2. O(logN)对数级 二分查找、平衡二叉树查找、跳表
   3. O(n)线性 数组遍历、链表遍历、二叉树遍历
   4. O(logN*n) 快速排序、归并排序、堆排序
   5. O(n^2) 冒泡、插入、选择排序
   6. O(2^n)指数级 回溯穷举算法，比如把皇后问题、斐波那契数列
   7. O(n!) 约等于 n^n 全排列
4. 均摊时间复杂度：适用于能动态扩容的数据结构，一般均摊时间复杂度就等于最好时间复杂度。

### 数组：
1. 定义：数组用一组连续的内存空间，来存储一组具有相同数据类型的数据
2. 混淆点：数据结构 ！== 数据类型， js中的数组可以存储不同数据类型的数据，这个数组叫数据类型，是不同的编程语言自己做调整的实现，并不会完全按照数据结构的定义实现
3. 最大特点：可以按照下标快速查找数组元素
### 链表：
1. 定义：使用非连续的内存空间来存储数据，通过next指针将内存串联在一起

2. 组成：
   1. 一个链表节点由数据域data和指针域next组成，next指针用于存储下个节点的位置。
   2. 头指针：指向第一个节点的指针，每次访问链表时都从这个头指针依次遍历链表中的每个元素。头指针是必须存在的。
   3. 头节点：很多时候会在链表的头部附加一个节点， 该节点的数据域可以不存储任何信息，这个节点称为头节点。
   4. 混淆点：头指针 与 头节点 的关系： 当没有头节点，头指针指向第一个节点的位置；当有头节点，头指针指向头节点的位置
    ```
    //节点的结构
    Node: {value, next}
    // 创建一个单独的节点
    let newNode = new Node(value, null);
    ```
3. 混淆点： 理解指针/引用的概念。
```
// head是头指针没错，使用的时候，直接取值
Node p = head;  //用节点P存储头节点 可以理解为p指向头节点
p = p.next; //用p的存储当前头节点的下一个节点，可以理解为p指向头节点的下一个节点
```
4. 对节点的常用操作
   1. 遍历
   ```
   function traverse(head, value){
       let p = head;
       whild(p!==null){
           if(value && p.data === value ) return p; // 查找
           p = p.next;
       }
   }
   ```
   2. 插入
   ```
   function insert({head, value, P}){
       // 在头部插入
       let newNode = new Node(value, null);
       newNode.next = head;
       head = newNode;
       // 在尾部插入-基础版
       let newNode = new Node(value, null); 
       let p = head;
       whild(p!==null){
           p = p.next;
       }
       p = newNode;
       // 在尾部插入-优化版：添加尾指针tail指向尾节点
       ```
       let newNode = new Node(value, null); 
       let tail = Node(...); //记录链表尾节点的位置 此时需要额外判断是否为空链表
       if(head===null){
           head = newNode;
           tail = newNode;
       }else{
           tail.next = newNode;
           tail = newNode;
       }
       ```
       // 在尾部插入-优化版：引入一个虚拟头节点，不需要再额外判断是否为空链表
       ```
       let head = new Node(); //虚拟头节点不存储数据 
       let tail = head;
       let newNode = new Node(value, null);
       tail.next = newNode;
       tail = newNode;
       ```
       // 在给定节点P之后插入
       ```
       let newNode = new Node(value, null); 
       newNode.next = p.next;
       p.next = newNode;
       ```
   }
   ```
   3. 删除
   ```
   function delete(head,P){
       //删除给定节点P之后的节点
       ```
       if(p===null || p.next ===null){
           return;
       }
       p.next = p.next.next;
       ```
       //删除给定节点P——？？？？？
       ```
       
       ```
       //删除给定节点P—优化版：添加虚拟头节点
       ```

       ```
   }
   ```
5. 链表的类别：循环链表不常用，单向链表在面试中最常考！双向链表在工程中最常用
   1. 循环链表：`tail === head` 尾节点的指针指向头节点
   2. 双向链表:`Node{data, prev, next}`
   3. 双向循环链表
6. 配套力扣习题
   ```
    //必做
    203. 移除链表元素（简单） 100%
    876. 链表的中间节点（简单） 100% 两遍遍历做出来的 下次用快慢指针方法
    83. 删除排序链表中的重复元素（简单）
    剑指 Offer 25. 合并两个排序的链表（中等） 100%
    2. 两数相加（中等） 100% 数值相加会超出js最长数值限制导致出错 解决办法： 用0补位，直接计算各数位上相加和
    206. 反转链表（中等） 50%
    234. 回文链表（中等） 50%
    328. 奇偶链表（中等） 100%
    25. K 个一组翻转链表（困难）100%
    剑指 Offer 22. 链表中倒数第k个节点（简单） 0%
    19. 删除链表的倒数第 N 个节点（中等） 100%
    160. 相交链表（简单） 100%
    141. 环形链表（简单） 100%
    ```
7. 套路解题
    1. 特点：套路有限，代码实现难
    2. 套路：
    ```
    1. 都需要遍历
    2. 头节点尾结点空链表的特殊情况处理
    3. 引入虚拟节点简化编程
    ```
    3. 把最基础、最经典的题目练好，就超越了90%的人了


### 栈的定义
1. 定义：先进后出 后进先出
2. 栈的应用：
    1. 判断栈已满：count记录存储的数据个数，count===0为空, count === n 为满； 
3. 题型套路
    1. 以栈为背景：用栈实现队列、最小栈、栈排序
    2. 消消乐题目：字符串消消乐
    3. 单调栈题目：栈延伸出的新的数据结构，比较难，考的不多
4. 例题：
    1. 232.用栈实现队列：
        1. 解法一：直接入栈，出栈本质上是移到另一个栈
        2. 解法二：入队本质上是放进另一个栈再转移之前的栈，出栈直接出
        3. 总结：栈问题本质是两个栈来回倒腾
    2. 1047.删除连续重复字符
    3. 739.单调栈-每日温度：
        1. 解法一：暴力解法
        2. 解法二：单调栈 还没有得到结果的元素放在栈里等待操作，所以单调栈里存的数据一般要么是升序要么是降序
        3. 总结：一般单调栈能解决的问题，都能先用暴力解法解决，只不过时间复杂度稍高；
    4. 计算器/表达式求值例如计算"3+2*2"的值：
        ```
        // 准备两个栈 数字栈 + 运算符栈；
        // 遇到数字直接入栈；遇到运算符，如果运算符栈为空，直接入栈；如果是连续的数字，例如345，要先运算 5 + 4*10 + 3 * 100；
        // 如果运算符栈不为空，要进行比较
        //pre 表示当前栈顶运算符优先级，cur是要入栈的运算符优先级 
        if(pre >= cur){ // 之前是 * / , 现在是+ - 或都是一样的
            // 数字栈顶弹出数字参与计算
        }else{ // 之前是 + - , 现在是 * /
            // 运算符直接入栈
        }
        ```
5. 配套力扣习题：
    ```
    // 必做
    232.用栈实现队列 
    剑指 Offer 09. 用两个栈实现队列（简单）
    225.用队列实现栈（简单）
    面试题 03.05. 栈排序（中等）
    155. 最小栈（简单） 0%
    面试题 03.01. 三合一（简单） 
    20. 有效的括号（简单） 100%
    面试题 16.26. 计算器（中等） 100%
    772. 基本计算器 III（困难 力扣会员，比上一题多了括号）
    1047. 删除字符串中的所有相邻重复项（简单）
    剑指 Offer 31. 栈的压入、弹出序列（中等） 100%

    // 选做 第一遍学习 不建议做
    739. 每日温度（中等） 单调栈 100%
    42. 接雨水（困难）单调栈 100%
    84. 柱状图中最大的矩形（困难）单调栈
    面试题 03.06. 动物收容所（中等） 队列
    剑指 Offer 59 - II. 队列的最大值（中等） 单调队列
    剑指 Offer 59 - I. 滑动窗口的最大值（困难）单调队列
    ```

### 队列
1. 定义：先进先出，后进后出
2. 队列实现
   1. 基于数组实现队列：循环队列
        1. 出入队操作：head 头结点指针;tail 新结点要入队的位置
        ```
        let list = new Array(3); //[] head = 0, tail = 0;
        head === tail; //表示一个空队列
        //入队
        list = [0]; //head = 0, tail当前为0
        tail = (0 + 1) % 3; // 更新tail:tail指向结点要入队的位置, 即当前队尾的下一个位置坐标 1
        //入队
        list = [0, 1]; //head = 0, tail当前为1
        tail = (1 + 1) % 3; //tail指向结点要入队的位置, 即当前队尾的下一个位置坐标 2
        //入队
        list = [0, 1, 2]; // head = 0,当前tail=2 满足 (tail + 1) % n === head且队头head有数据 说明入队完就满了(tail下一个值应为3但无更多空间能入队)
        // 出队
        list = [null, 1, 2]; // 队头出队，head变为1 && 队列头没有数据，所以可以往队列头入队，在上一步中tail已经从2变成3了, 新tail = 3 % 3  = 0; 表示下一个可以入队的位置下标为0
        // 入队
        list = [3, 1, 2]; //head=1, 当前tail=0, 满足 (tail + 1) % n === head 且队头head有数据， 说明入完队就满了(tail下一个值应为1但无更多空间能入队)
        ```
        2. 判断循环队列已满
        ```
        // 在每次要入队一个元素，满足以下规律：
        head === tail; //空数组
        head === (tail + 1) % n; //入队后队列将满
        // 入、出队 head、tail的变化：
        head = (head + 1) % n;
        tail = (tail + 1) % n;
        ```
    2. 基于链表实现队列
3. 题型套路


### 递归与分治
1. 定义：
    1. 分治：分而治之，是一种思想
    2. 递归：函数调用自己，是一个编程技巧
2. 递归复杂度
    1. 空间复杂度 = 递归树的高度 = 递归调用栈的深度
    2. 时间复杂度：有两种分析方式
        1. 始终成立：递归树法：时间复杂度 = 递归树结点数 * 结点的执行时间。
        2. 偶尔成立：递推公式法
3. 递归常见问题：
    1. 堆栈溢出(非bug导致) 解决办法：限制递归深度 或者 改用非递归方法
    2. 重复计算。 解决办法：备忘录法 或者 DP动态规划
4. 判断是否适合用递归方法：
    1. 规模更小的问题 与 规模更大的问题，解决思路是相同的
    2. 利用子问题的解，可以组合得到愿问题的解
    3. 存在最小子问题，可以直接返回结果(存在递归终止条件)  
5. 递归编码
    1. 宗旨：假设子问题已经解决， 在此基础上思考如何解决当前的原问题，即`推导逻辑+终止条件`,推导过程可以画递归树，但忽略递归执行过程的细节，否则容易陷入思维误区。
    2. 技巧：寻找重复结构、总结递归逻辑(终止条件)
6. 例题：递归编程是基础中的基础，必须练习熟练
    1. 70.爬楼梯
    2. 细胞分裂：1个细胞的生命周期是3小时。求n个小时后，容器内有多少活细胞(分裂完、死亡完之后)？细胞会在每个小时的开头先分裂后死亡。
    3. 剑指offer06.从尾到头打印链表
7. 配套习题
```
剑指 Offer 10- I. 斐波那契数列（简单） 100%
剑指 Offer 10- II. 青蛙跳台阶问题（简单） 100%
面试题 08.01. 三步问题（简单）100%
剑指 Offer 06. 从尾到头打印链表（简单） 100%
剑指 Offer 24. 反转链表（简单） 100%
剑指 Offer 25. 合并两个排序的链表（中等）
剑指 Offer 16. 数值的整数次方（中等）
面试题 08.05. 递归乘法（中等）
```

### 排序算法
1. 排序算法的评价指标:
    1. 时间复杂度
        1. 有序度：两个元素捉对比较，升序的个数
        2. 逆序度：两个元素捉对比较，逆序的个数
        3. 与满度的关系：`n * (n-1) / 2` = 逆序度 + 有序度; 
        4. 平均有序度 = 平均逆序度= `n * (n-1) / 4`
        3. 降低空间复杂度===增加有序度===减少逆序度
    2. 空间复杂度：就看执行最多的代码执行了几次
    3. 原地性：排序过程中是否需要新的存储空间。通过原地倒腾的就满足原地性
    4. 稳定性：相等元素排序后的先后顺序是否改变
    5. 注意原地性🆚空间复杂度：原地排序的空间复杂度不一定是O(1)，因为有可能是迭代算法，调用栈对内存的消耗，是要计入空间复杂度里的；但空间复杂度是O(1)的一定是原地排序的
2. 排序方法分类：
    1. 冒泡排序：
        1. 方法：将元素每个都跟相邻元素比较，将更大的放在后面，再将更大的这个继续跟相邻元素比，直到放在最后。每趟冒泡操作会将至少1个元素放在该放的位置，重复n遍，就完成了整个排序
        2. 优化：提前退出冒泡的条件：当一个元素经历了一轮冒泡，但一次都没有冒泡，说明当前已经是有序的了，就可以停止冒泡了
        3. 编码注意点：for循环的判断语句是`j<n-i-1`
        4. 评价指标：最好情况是正序，最坏是倒序
            1. 时间：最好O(n);最坏O(n^2);平均O(n^2);
            2. 空间：O(1)
            3. 原地：是
            4. 稳定：是
        5. 代码
            ```
            var pipe = function(nums){
                let len = nums.length;
                for(let i=0; i<len; i++){
                    let stop = true; //是否要提前结束
                    for(let j=0; j< len-i-1; j++){ //注意j的取值范围
                        if(nums[j]>nums[j+1]){
                            let tmp = nums[j+1];
                            nums[j+1] = nums[j];
                            nums[j] = tmp;
                            stop = false; //只要交换了，就不应提前结束
                        }
                    }
                    if(stop) return nums; //都是有序的就不用再接着循环了
                }
                return nums;
            }
            ```
    2. 插入排序：把没排的依此跟排完的比，放在该放的位置上
        1. 方法：将数组分为已排序区间和未排序区间。将未排序区间的元素依次放进已排序区间里该放的位置。放的过程不需要开辟额外空间，未排序空间空出来的位置存放已排序的元素 [已排序，未排序] 初始化已排序区间的元素只有一个，就是数组的第一个元素。 指针i表示未排序的头部位置，0～i-1 都是已排序，让i位置元素 跟i-1比、跟i-2比...跟i-n比, 从后往前比，直到找到该插入的位置。直到未排序区间空了，排序结束。
        2. 编码注意点： for(i=1) 从第二个元素开始遍历
        3. 评价指标：最好情况正序，最坏是倒序
            1. 时间：最好O(n);最坏O(n^2);平均O(n^2);
            2. 空间：O(1)
            3. 原地：是
            4. 稳定：是
        4. 代码
            ```
            var pipe = function(nums){
                let len = nums.length;
                let i = 1;
                for(; i<len; i++){
                    let j = i-1;
                    let val = nums[i];
                    if(nums[j]<val) continue;
                    while(nums[j]>val && j>-1){
                        nums[j+1] = nums[j]
                        j--;
                    }
                    nums[j+1] = val;
                }
                return nums;
            }
            ```
    3. 选择排序
        1. 方法：将数组分为[已排序区间、未排序区间],初始化已排序区间为[]，指针i表示未排序区见的头部位置，然后在未排序区间中遍历j，j的范围是从i到末尾，选择要排(最大or最小)的元素，j插入到已排序区间的末尾后一位位置也就是i位置的元素，原来的i位置元素就去到j的位置了(交换了一下)。
        `[2,6,3,2,4,1] => [1,6,3,2,4,2]`
        2. 编码注意点：`for(i<n-1)` 最后剩一个时，后面就没有可比的了
        3. 评价指标：最好情况正序，最坏是倒序
            1. 时间：都是O(n^2);
            2. 空间：O(1)
            3. 原地：是
            4. 稳定：否
        4. 代码
            ```
            var pipe = function (nums) {
                let len = nums.length;
                for (let i = 0; i < len-1; i++) {
                    let minInd = i;
                    for (let j = i + 1; j < len; j++) {
                        if (nums[j] < nums[minInd]) {
                            minInd = j;
                        }
                    }
                    if (minInd !== i) {
                        let tmp = nums[i];
                        nums[i] = nums[minInd];
                        nums[minInd] = tmp;
                    }
                    console.log(nums);
                }
                return nums;
            }
            ```
    4. 归并排序
        1. 利用分治思想，利用递归实现 
        2. 实现思路：将数组分成前半段和后半段分别排序，然后merge即 用双指针方法分别对比两个数组的值进行排序合成一个数组。过程中需要额外申请一个数组暂存数据，所以记得最后再拷贝回去。每个前半段/后半段数组又可以利用递归算法拆解成更小的两个数组运算
        ```
        r = (p+q)/2;
        merge(p,q) = compareAndMerge(  merge(p,r) + merge(r+1,q) ); 
        ```
        3. 评价指标：
            1. 时间：
                1. 递推公式法：
                ```
                // 现有条件
                T(n) = T(n/2) + T(n/2) + n; //任何时间，只有1个合并操作在执行，所以merge(n)的时间与n成正比
                T(1) = C; //长度为1的不需要分解，时间是个常量
                // 推导目标：得到 n 与 C 的关系表达式
                T(n)= 2* T(n/2) + n 
                    = 4 * T(n/4) + 2*n 
                    = ... //不断
                    = 2^k * T(n/(2^k)) + k*n;
                由于T(1)==c, 即n/(2^k) == 1 得到 k = log2(n);
                带入得到T(n) = 2^(log2(n)) * T(1) + log2(n) * n = n*C+n*log2(n) ;
                // nc是常量，所以时间复杂度为O(n*log2(n)) 即 O(log(n))
                ```
                2. 递归树法：
                ```
                // 时间复杂度 = 递归树结点数 * 结点的执行时间. 
                T(n) = T(n/2) + T(n/2) + n; //任何时间，只有1个合并操作在执行，所以merge(n)的时间与n成正比
                // 在每个结点中，merge是占大部分时间的，而将T(n)= T(n/2) + T(n/2) 变成两个新调用并不耗时很多；
                // 所以第个节点耗时公式就是T(n) = n, 
                // 第二层T(n/2) = n/2, 第二层有两个结点，所以第二层总时间 n/2* 2 = n; 
                // 发现规律为每一层有n个结点，每个结点耗时T(n/n) 每一层总时间为 T(n/n) * n = n/n*n = n;
                // 从n到1一共有log2(n)层,这也是递归过程中调用栈的数量
                // 所以递归树的总时间是 n * log2(n) 即 O(log(n))
                ```
            2. 空间：函数调用栈空间log2(n)+合并数组的空间n = O(log(n)+n) 
            3. 原地：否
            4. 稳定：是 只要相等的数按照原来的顺序放进新数组就能保证是稳定的
        4. 代码
            ```
            var pipe = function (nums) {
                let len = nums.length;
                if(len===1) return nums;
                let r = Math.floor(len/2);
                nums = merge(
                    pipe(nums.slice(0,r)), //注意r
                    pipe(nums.slice(r))
                );
                return nums;
            }
            var merge = function(left=[],right=[]){
                let arr = [];
                let i=j=0;
                while(i<left.length && j<right.length){
                    if(left[i]<=right[j]){
                        arr.push(left[i++]);
                    }else{
                        arr.push(right[j++]);
                    }
                }
                arr = arr.concat(left.slice(i)).concat(right.slice(j))
                return arr;
            }
            ```
    5. 快速排序：
        1. 方法：递归
        2. 思路：
            1. 总体思路：将数组分为左-分区点-右三个区域，左边的都比分区点小，右边的都比分区点大。然后分别对左边、右边迭代进行分区等。
            2. 如何获得分区点：初始化时一般将最后一个值作为分区点。
            3. 流程：使用双指针i和j,分别放在除了分区点外的第一个元素和最后一个元素上，i和j处元素分别跟分区点比较再互相比较，最终的目标是各处的值满足 i < 分区点 < j, 所以如果 i>分区点&&j<分区点，就将i和j的值对调，ij都移动，如果 i>分区点||j<分区点，就正常将j前移||i后移，就是符合大小比较的那个指针移动，不符合的指针不动，目的是让大的就呆在大区小的就呆在小区，继续比较直到i>=j停止，最后将分区点 插入到j前面就结束了。过程简述为[...未处理,分区点] => [...小,...大,分区点] => 对大/小两个区域 递归 比较 => [...小, 分区点, ...大]
        3. 评价指标：
            1. 时间：
                1. 最好情况分区点接近平均数：O(n*log(n)) 即O(log(n)) 参照归并排序的分析，是一样的
                2. 最坏情况分区点极其不平均：O(n*(n-1)/2) = O(n^2)
                3. 平均情况分区点: O(n*log(n)); 推导公式较难确认时间，递归树相对容易，每一层的总时间是能确认的为n，但层数是不确定的，因为分区的情况不明确，只能取平均值，抽象成时间复杂度每层还是O(log(n))，所以T(n)= O(n)*O(log(n)) = O(n*log(n))
            2. 空间：
                1. 最好情况分区平均：O(log2(n)) = O(log(n))
                2. 最坏情况分区极端：递归的最大深度是n，空间复杂度就是O(n)
                3. 平均情况：O(log(n))
            3. 原地：是 两种思路都是原地
            4. 稳定：否
        4. 代码
            ```
            // 快速排序 包含q
            var pipe = function (nums,p,q) {
                let len = q-p+1;
                if(len<2) return nums.slice(p,q+1);
                let needle = q;
                let i=p, j = needle-1;
                while(i<=j){
                    if(nums[i]<nums[needle] && nums[j]>nums[needle]){
                        i++;
                        j--;
                    }else if(nums[i]>nums[needle] && nums[j]<nums[needle]){
                        [nums[i],nums[j]] = [nums[j],nums[i]];
                        i++;
                        j--;
                    }else if(nums[i]>nums[needle]){ //都大于
                        j--;
                    }
                    // else if(nums[j] < nums[needle]){ //都小于
                    //     i++;
                    // }
                    else { // 易错点 没有处理等于的情况
                        i++;
                    }
                }
                // i>j
                // let left = nums.slice(p, i); //不包含结束位i，所以实际长度是到j
                // let right = nums.slice(i, needle); //不包含needle
                let arr = [...pipe(nums,p,i-1), nums[needle], ...pipe(nums,i,needle-1)];
                return arr;
            }
            ```
3. 常考题型
    1. 特殊排序
    2. Top K (经典问题 一定要熟练) 例题：215.数组中的最大的第k个元素
    3. 链表上的排序 例题 147.对链表进行插入排序(中等)
    4. 排序预处理
4. 例题
```
面试题 10.01. 合并排序的数组（简单） 100%
242. 有效的字母异位词（简单） 做过
1502. 判断能否形成等差数列（简单） 0% 快速排序没写出来
252. 会议室（简单）
56. 合并区间（中等） 
剑指 Offer 21. 调整数组顺序使奇数位于偶数前面（简单）
75. 颜色分类（中等）
147. 对链表进行插入排序（中等）
148. 排序链表（中等） 链表上的归并排序
215. 数组中的第K个最大元素（中等） 
面试题 17.14. 最小K个数（中等）
剑指 Offer 51. 数组中的逆序对（困难）
```

### 二分查找
1. 定义：在有序数组中快速查找，也叫折半查找，要求数组必需有序。在链表中，由于链表不支持通过下标直接查询，所以链表中的二分查找法并不合适。
2. 思路：查找数组中的中间位置，比较后决定去前面小的区域or后面大的区域查询。在小的/大的区域，再重复：先查找区域中间位置，之后比较到前面查还是到后面查。
3. 实现: 数组arr,长度为n，要查找的值value在数组中的位置,没有则返回-1。注意，low+high容易造成大数越界，所以(low+high)/2的写法可以改成 `low + (high-low)/2 `
    1. 递归法 
        1. 实现
        ```
        function bsearch(arr, low, high, value){
            if(low>high) return -1;
            let mid = (low+high) /2;
            if(arr[mid]===value) return mid;
            if(arr[mid]<value) return bsearch(arr,mid+1,high,value);
            if(arr[mid]>value) return bsearch(arr,low,mid-1,value);
        }
        bsearch(arr,0,n-1,value);
        ```
        2. 复杂度分析
            1. 时间复杂度：
            ```
            T(n) = T(n/2) + C 
                 = T(n/4) + 2C
                 = T(n/8) + 3C
                 = ...
                 = T(n/2^k) + k*c
                 = ...
                 = T(1) + x * C； //此时x值为log2(n)
                 = C1 + log2(n) * C
            => O(logN)
            ```
            2. 空间复杂度：递归树最大深度，即函数调用栈数量O(log2(n)) => O(logN)
    2. 非递归法 
        1. 实现
        ```
        function bsearch(arr, n, value){
            let low = 0, high = n-1;
            while(low<=high>){
                let mid = (low+high) /2;
                if(arr[mid]===value){
                    return mid;
                }else if(a[mid]<value){
                    low = mid + 1;
                }else{
                    high = mid -1;
                }
            }
            return -1;
        }
        ```
        2. 时间复杂度：最好一下就找到O(1),最坏没找到O(logN)
4. 套路题型：往往不会一眼看出来可以用二分查找，需要先变形
```
查找第一个/最后一个x、//可以用前后探测法，判断当前等于valu的值是不是第一个或者最后一个
查找等于/大于等于/小于等于x的元素、
33.搜索旋转排序数组 //循环有序数组 例如[3,4,5,1,2,3]就是将数组的一部分前后换位。所以没办法直接确定到哪边去查。但可以先判断哪边是有序的，比如arr[low]<arr[mid],那肯定从low到mid是有序的，那就先从[low,mid-1]这个数组中做二分查找，如果找不到再去右边那个非完全排序的数组中找；如果arr[low]>arr[mid]，那肯定[mid,high]这个数组是有序的，就先从这里找；循环排序数组的宗旨就是先从有序子数组中进行二分查找
153.寻找旋转排序数组的最小值
852.山脉数组的峰顶索引
69.求x的平方根
```
5. 课后习题
```
704. 二分查找（简单） 标准二分查找
374. 猜数字大小（简单）
744. 寻找比目标字母大的最小字母（简单）
35. 搜索插入位置（简单）
34. 在排序数组中查找元素的第一个和最后一个位置（中等）
面试题 10.05. 稀疏数组搜索（简单） 
33. 搜索旋转排序数组（中等）无重复数据 
153. 寻找旋转排序数组中的最小值（中等） 无重复数据
852. 山脉数组的峰顶索引（简单）峰值二分
162. 寻找峰值（中等）峰值二分
367. 有效的完全平方数（简单）二分答案
69. x 的平方根（简单）二分答案
74. 搜索二维矩阵（中等） 二维转一维，二分查找
//以下为选做，精力充沛的同学可以做一下：
658. 找到 K 个最接近的元素（中等）
875. 爱吃香蕉的珂珂（中等）二分答案
81. 搜索旋转排序数组 II（中等）有重复数据
154. 寻找旋转排序数组中的最小值 II（困难） 有重复数据
4. 寻找两个正序数组的中位数（困难）
```

### Hash 哈希表
1. 课后题
```
两数之和（简单） 两数之和
15. 三数之和（中等）三数之和
160. 相交链表（简单） 
141. 环形链表（简单） 判断链表中是否存在环 
面试题 02.01. 移除重复节点（中等） 借助哈希表
面试题 16.02. 单词频率（简单）
面试题 01.02. 判定是否互为字符重排（简单） 排序、哈希表、位图 
剑指 Offer 03. 数组中重复的数字（简单） 
242. 有效的字母异位词（简单）
49. 字母异位词分组（中等）
136. 只出现一次的数字（简单）哈希表、位图、排序、位运算
349. 两个数组的交集（简单）哈希或者排序，二分查找优化
1122. 数组的相对排序（中等）位图
706. 设计哈希映射（简单）自己实现HashMap
146. LRU 缓存机制（中等）标准的LRU
面试题 16.21. 交换和（中等） 找规律，可以借助哈希表优化
```

### 二叉树
1. 定义
    1. 满二叉树：所有的叶子结点都是满的
    2. 完全二叉树：只有最后一层的最后一个叶子是空的，其余都是满的，就是完全二叉树
2. 存储方式：
    1. 基于指针：每个结点值为data,有left、right两个指针，没有的叶子指向null
    2. 基于数组：某结点下标为i，父节点是i/2，左子节点是i*2，右子节点是2*i+1; 通常从数组下标为1的位置开始存储比较好算；但是这种方式，对非完全二叉树，会非常浪费空间
3. 二叉树遍历：
    1. 深度优先遍历："*序"指的是根的遍历顺序，先算根，就是前序，后算根就是后序
        1. 前序遍历：根-前序左子树-前序右子树
        ```
        function fn(root){
            if(root===null) return;
            console.log(root.value);
            fn(root.left);
            fn(root.right);
        }
        ```
        2. 中序遍历：中序左子树-根-中序右子树
        ```
        function fn(root){
            if(root===null) return;
            fn(root.left);
            console.log(root.value);
            fn(root.right);
        }
        ```
        3. 后序遍历：后序左子树-后序右子树-根
        ```
        function fn(root){
            if(root===null) return;
            fn(root.left);
            fn(root.right);
            console.log(root.value);
        }
        ```
    2.广度优先遍历：按层级遍历
4. n个结点的树的高度：介于两者之间
    1. 最大：n
    2. 最小：log2(n) 完全二叉树
5. 高度为h的二叉树，有多少结点：介于两者之间
    1. 最少结点：h
    2. 最多结点：2^h - 1
6. 复杂度：
    1. 时间复杂度O(n) 
    2. 空间复杂度O(h) h是二叉树的高度
7. 二叉查找树
    1. 定义：是一种特殊的二叉树，结点node的左子树中的任意结点值都小于node的值同时右子树中任意结点的值大于node的值。
    2. 查找操作：注意处理根为null的情况。
        1. 查找方法：
            1. 递归查找。先判断根、如果比根小，就在左子树中递归查找；如果比根大，就在右子树中递归查找。时间复杂度O(h)
            2. 非递归实现(推荐)：while循环，小的就找左子树，大的找右子树。时间复杂度O(n)
        2. 查找顺序
            1. 从小到大排列：左-根-右
            2. 从大到小排列：右-根-左
    3. 插入操作：
        1. 递归插入：与根比，判断要插入左子树还是右子树。如果左右子树为空，那就直接放在左/右子树的位置；如果不为空，那就一路递归遍历左/右子树,直到放到那个左/右叶子为空且数值大小正确的位置。注意处理根为null的情况。时间复杂度O(h) 空间复杂度O(h)
        2. 非递归：用while循环一路判断。时间复杂度O(n)
    4. 删除操作：
        1. 要删除的节点没有子节点：需要把父节点的指向删除节点的指针设置为null
        2. 要删除的节点有一个子节点：把要删除节点的父节点的指针，指向删除节点的指针指向的子节点
        3. 要删除的节点有两个子节点：找到大小最接近的节点替代被删除节点。要么找到该删除节点的右子树中的最小节点；要么找到该删除节点的左子树中的最大节点，这两个节点的值都是跟被删除节点的值挨着的，找到后用它进行替换，替换后记得吧它从原来的位置删除
8. 平衡二叉查找树
    1. 定义：任意结点的左子树与右子树的高度之差不大于1
    2. 平衡二叉查找树的高度h 接近 log2(n)
9. 套路题型：就是课后题这8个大类。重点中的重点！！！必需搞懂搞会搞熟练
    5. LCA最近公共祖先
10. 课后题
    1. 二叉树的前、中、后序遍历
    ```
    144. 二叉树的前序遍历（简单） 100%
    94. 二叉树的中序遍历（简单） 100%
    145. 二叉树的后序遍历（简单） 100%
    589. N 叉树的前序遍历（简单） 100%
    590. N 叉树的后序遍历（简单） 100%
    ```
    2. 二叉树按层遍历
    ```
    剑指 Offer 32 - I. 从上到下打印二叉树（中等）  80% 应该用别的方法再试试
    102. 二叉树的层序遍历（中等） 100% 之前做的
    剑指 Offer 32 - III. 从上到下打印二叉树 III（中等）100%
    429. N 叉树的层序遍历（中等） 100%
    513. 找树左下角的值（中等）100%
    ```
    3. 二叉树上的递归
    ```
    104. 二叉树的最大深度（简单） 100% 之前做的
    559. N 叉树的最大深度（简单） 100%
    剑指 Offer 55 - II. 平衡二叉树（中等）  100%
    617. 合并二叉树（简单）100%
    226. 翻转二叉树（简单）100% 只用了DFS 有时间再用BFS写一遍
    101. 对称二叉树（中等）100% 之前做过的
    98. 验证二叉搜索树（中等）100% 递归做法 试一下中序遍历法
    ```
    4. 二叉查找树
    ```
    剑指 Offer 54. 二叉搜索树的第k大节点（中等）100%
    538. 把二叉搜索树转换为累加树（中等）100%
    面试题 04.06. 后继者（中等）100% 做出来了，但是做法很辣鸡！完全没有利用上有序搜索树的特性，重新做！
    ```
    5. LCA最近公共祖先
    ```
    236. 二叉树的最近公共祖先（中等） 
    剑指 Offer 68 - I. 二叉搜索树的最近公共祖先（中等） 
    ```
    6. 二叉树转单、双、循环链表
    ```
    114. 二叉树展开为链表（中等）
    面试题 17.12. BiNode（中等）
    剑指 Offer 36. 二叉搜索树与双向链表（中等）
    面试题 04.03. 特定深度节点链表（中等）
    ```
    7. 按照遍历结果单向构建二叉树
    ```
    105. 从前序与中序遍历序列构造二叉树（中等）
    889. 根据前序和后序遍历构造二叉树（中等）
    106. 从中序与后序遍历序列构造二叉树（中等）
    剑指 Offer 33. 二叉搜索树的后序遍历序列（中等）
    ```
    8. 二叉树的最长链路
    ```
    543. 二叉树的直径（简单）
    剑指 Offer 34. 二叉树中和为某一值的路径（中等）
    124. 二叉树中的最大路径和 （困难）
    437. 路径总和 III （困难）
    ```

### 堆
1. 定义：是一个完全二叉树，堆中的值都大于等于所有子树中节点的值 或者 堆中的值都小于等于所有子树中节点的值
2. 分类：大顶堆(堆顶的是最大的) or 小顶堆(堆顶的是最小的)
3. 存储：堆是完全二叉树，适合用数组来存储 从1开始存比较好计算 父亲i,左子2i,右子2i+1
4. 操作 基本操作：堆化操作(向上or向下) 对调节点
    1. 插入数据：加在最后做叶子节点，然后自下而上堆化
    2. 取堆顶元素
    3. 删除堆顶元素：防止出现空洞，可以将叶子节点作为堆顶，再自上而下堆化操作
    4. 更新元素值
5. 堆化。。
6. 没看完。。

### 回溯
1. 核心思想：枚举所有的值，找出其中满足期望的可行解。
2. 求解过程：多阶段决策模型：每个阶段对应多个选择，从可选的选择列表中，任意选择一个，继续进行下一阶段的决策。
3. 决策树：回溯就是一棵决策树，回溯穷举所有解来查找可行解的过程，就是在决策树进行遍历的过程。遍历过程中记录的路径就是解
4. 实现：回溯一般使用递归来实现
5. 例题：
    1. 全排列 给定n个不重复的数，求所有的排列组合
6. 课后习题
```
面试题 08.12. 八皇后（困难）
37. 解数独
17. 电话号码的字母组合（中等）
77. 组合（中等） 给n个数返回所有k个数的组合
78. 子集（中等） 所有的组合 100%
90. 子集 II（中等）有重复数据
46. 全排列（中等） 所有排列  100%
47. 全排列 II（中等） 有重复数据
39. 组合总和（中等） 选出某几个数相加为给定和，无重复数据，可以使用多次，不能有重复答案  100%
40. 组合总和 II（中等）选出某几个数相加为给定和，有重复数据，只能使用一次，不能有重复答案  100%
216. 组合总和 III（中等） 选出k个数相加为给定和，没有重复数据，只能使用一次  100%
131. 分割回文串（中等） 100%
93. 复原 IP 地址（中等） 100%
22. 括号生成（中等） 100%
```

### DFS && BFS
1. 课上习题
```
拓扑排序 检测环

剑指 Offer 13. 机器人的运动范围（中等）（已讲）
面试题 08.10. 颜色填充（简单）
面试题 04.01. 节点间通路（中等）
1.   岛屿数量（中等）  100%
面试题 16.19. 水域大小（中等） 
207 课程表（中等） BFS 50% -- DFS 没有做出来 
79  单词搜索（中等）
1306  跳跃游戏 III（中等） 
752  打开转盘锁（中等）（已讲）
面试题 17.22. 单词转换（中等）

以下选做：
面试题 17.07. 婴儿名字（困难）
529  扫雷游戏（困难）
127  单词接龙（困难）
126  单词接龙 II（困难）
```

### 动态规划
1. 原理：构建多阶段决策模型。把每一阶段中重复的状态合并，只记录不同的状态(剪枝)，然后基于上一阶段的状态集合，来推导下一阶段的状态集合。可以用一个二维数组来记录每一阶段的状态结果。 适用于 用回溯可以解决的多阶段模型问题，同一阶段有重复状态的问题，可以使用动态规划
2. 解题过程
    1. 确认前提：可用回溯解决
    2. 构建多阶段决策模型
    3. 查看是否存在重复字问题
    4. 定义状态
    5. 定义状态转移方程
    6. 画状态转移表
    7. 编写代码
3. 题目细分类型：最值、可行、计数
4. 题目类型 && 配套习题：
    1. 背包问题：课程链接：https://www.xzgedu.com/live_pc/l_616a53cfe4b0a052bf66f748
        1. 0-1背包问题：每个物品只有1个。每一层决策是决定 是否放入该物品
        2. 完全背包问题：每个物体有无限多个。每一层决策是决定，怎样放入该物品 1～n个 (视频第42分钟开始)
        ```
        416. 分割等和子集 100%
        494. 目标和 100%
        322. 零钱兑换  完全背包问题  100%
        518. 零钱兑换 II  100%
        ```
    2. 路径问题
    ```
    64. 最小路径和 100%
    剑指 Offer 47. 礼物的最大价值  100%
    120. 三角形最小路径和 100%
    62. 不同路径
    63. 不同路径 II  100%
    ```
    3. 打家劫舍 & 股票买卖
        1. 树状DP: 一般后序遍历，从下往上推，每个节点有两个状态，node[0]、node[1], 表示当前节点偷或不偷两种情况下，当前节点及以下所有结果的最大值
    ```
    198. 打家劫舍  100%
    213. 打家劫舍 II   100%
    337. 打家劫舍 III  (树形DP) 100%
    714. 买卖股票的最佳时机含手续  100%
    309. 最佳买卖股票时机含冷冻期 100%
    ```
    4. 爬楼梯问题
    ```
    70. 爬楼梯 100%
    322. 零钱兑换  100%
    518. 零钱兑换 II  100%
    剑指 Offer 14- I. 剪绳子  100%
    剑指 Offer 46. 把数字翻译成字符串  100%
    139. 单词拆分
    ```
    5. 匹配问题(LCS、编辑距离)
    ```
    1143. 最长公共子序列
    72. 编辑距离 
    ```
    6. 其他
    ```
    437. 路径总和 III (树形DP)
    300. 最长递增子序列
    ```


### 双指针
```
344. 反转字符串 100%
面试题 16.24. 数对和（例题1）  100%
1. 两数之和 100%
15. 三数之和 100%
剑指 Offer 21. 调整数组顺序使奇数位于偶数前面   100%
75. 颜色分类  100%
283. 移动零已排序未排序指针（例题2）
面试题 16.06. 最小差类似合并两个有序数组（例题3）
面试题 17.11. 单词距离类似合并两个有序数组
```

### 滑动窗口
也是类似双指针的方式
```
剑指 Offer 57 - II. 和为s的连续正数序列 
剑指 Offer 48. 最长不含重复字符的子字符串  100%
438. 找到字符串中所有字母异位词 
76. 最小覆盖子串 
```