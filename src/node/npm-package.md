# NPM

## NPM 基础

### 一些 npm 包

#### lint-staged 工具

1. 作用：帮助在提交代码之前运行代码质量检查的工具。它会自动运行代码格式化工具和代码检查工具（如 ESLint、Prettier）在暂存的 Git 文件上，以确保提交的代码质量。
2. 配置文件 .lintstagedrc

    ``` code
        {
            //作用: 对所有暂存的 TypeScript 文件（.ts）运行指定的命令
            "*.ts": [ 
                "nx affected:lint --fix --files"  //使用 Nx 工具来运行代码检查（lint）--fix: 自动修复发现的代码问题 --files: 指定仅对暂存的文件运行代码检查
            ], 
            //作用: 对所有暂存的 SCSS 文件（.scss）运行指定的命令
            "*.scss": [
                "npx stylelint --fix" // 使用 Stylelint 工具来运行代码检查（lint）。Stylelint 是一个强大的 CSS 和 SCSS 的代码检查工具
            ]
        }
    ```

## PNPM 基础

### pnpm

1. 作用：pnpm 不是一个普通的包，它是一种快速、节省磁盘空间的包管理器，与 npm 和 yarn 类似，但它有一些独特的特点和优势
2. 安装包命令：pnpm install
3. 下载位置：也是项目下的 node_modules 文件夹
4. 优势：
   1. 速度快，性能优越: pnpm 的安装速度通常比 npm 和 yarn 更快，因为它使用了一种独特的方式来管理依赖
   2. 节省磁盘空间: pnpm 通过符号链接的方式来管理依赖，避免了重复安装相同的依赖包，从而节省了大量磁盘空间。 符号链接 是什么❓
   3. 一致性好，严格依赖管理: pnpm 强制安装依赖时的严格模式，确保不同项目之间的依赖不会相互干扰。 怎么做到的❓
5. 高效管理优势详解：
   1. 符号链接 (Symbolic Links)：pnpm 使用符号链接来管理依赖包。与 npm 和 yarn 将每个依赖包复制到项目的 node_modules 目录不同，pnpm 将依赖包存储在全局存储区，并在项目的 node_modules 目录中创建符号链接指向这些全局存储区中的包
      1. 位置：在哪 ❓ 符号链接在哪 ❓
      2. 节省磁盘空间: 多个项目可以共享相同的依赖包，避免了重复安装和存储相同的包
      3. 提高安装速度: 因为依赖包只需要下载一次，后续项目安装时只需要创建符号链接，减少了文件复制的时间
   2. 分层结构的 node_modules：pnpm 采用了一种分层结构的 node_modules 目录。传统的 node_modules 目录是一个平铺的结构，所有依赖包都直接放在项目的 node_modules 目录下。pnpm 将依赖包按照依赖关系进行分层存储，每个包的依赖项都存储在它自己的 node_modules 目录下
      1. 减少依赖冲突: 分层结构确保不同版本的依赖包可以共存，减少了依赖冲突的风险。
      2. 提高模块解析性能: 分层结构使得模块解析更加高效，因为每个模块的依赖项都存储在它自己的目录下，而不是平铺在项目的 node_modules 目录中
   3. Content-Addressable Storage： pnpm 使用内容寻址存储（Content-Addressable Storage），即依赖包的存储是基于包内容的哈希值。这意味着相同内容的包只会存储一次，无论它们的版本号如何
      1. 节省磁盘空间: 相同内容的包只会存储一次，减少了磁盘空间的使用。
      2. 提高安装速度: 当安装相同内容的包时，只需要创建符号链接，减少了文件复制的时间
   4. 高效的缓存机制：pnpm 具有高效的缓存机制，可以缓存已经下载的包，以供后续安装使用。这减少了重复下载相同包的时间，提高了安装速度
6. Peer Dependency: pnpm 处理 Peer Dependencies 的方式与 npm 类似，但提供了一些额外的机制来帮助管理这些依赖
   1. 严格依赖管理: pnpm 强制安装 peer dependencies 到项目的顶层 node_modules，确保所有包共享同一个版本
   2. 安装警告: 如果 peer dependencies 未满足或版本不匹配，pnpm 会发出警告，提示开发者手动解决这些问题
   3. 